<!DOCTYPE html><html lang="en"><head><title>lib/utils/style_helpers</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="citare-relative-root" content="../../"><meta name="citare-document-path" content="lib/utils/style_helpers"><meta name="citare-project-path" content="lib/utils/style_helpers.coffee"><meta name="citare-github-url" content="https://github.com/druide/citare-scriptum"><link rel="stylesheet" type="text/css" media="all" href="../../assets/style.css"><script type="text/javascript" src="../../assets/behavior.js"></script><body><div id="bg"></div><div id="meta"><div class="file-path"><a href="https://github.com/druide/citare-scriptum/blob/master/lib/utils/style_helpers.coffee">lib/utils/style_helpers.coffee</a></div></div><div id="document" class="codedoc"><div class="segment nocomment"><div class="comments"></div><div class="code"><div class="wrapper">path = <span class="built_in">require</span> <span class="string">'path'</span>

_ = <span class="built_in">require</span> <span class="string">'underscore'</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><h1><a name="style-helpers" class="anchor" href="#style-helpers"><span></span></a>Style Helpers</h1>
<p>A collection of helpful functions to support styles and their behavior.</p></div></div><div class="code"><div class="wrapper"><span class="built_in">module</span>.<span class="built_in">exports</span> = StyleHelpers =</div></div></div><div class="segment nocode"><div class="comments"><div class="wrapper"><p>Generate a table of contents as a tree of {node: {…}, children: []} objects.</p>
<p>We want a pretty complex hierarchy in our table of contents:
buildTableOfContents: (files) -&gt;</p></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Given an array of markdowned segments, convert their list of headers into a hierarchical
outline (table of contents!)</p></div></div><div class="code"><div class="wrapper">  <span class="attribute">outlineHeaders</span>: <span class="function"><span class="params">(segments)</span> -&gt;</span>
    headers = segments.reduce <span class="function"><span class="params">( (a, s) -&gt; a.concat s.headers )</span>, []
    <span class="title">return</span> [] <span class="title">unless</span> <span class="title">headers</span>.<span class="title">length</span> &gt; 0

    <span class="title">nodes</span> = []
    <span class="title">for</span> <span class="title">header</span> <span class="title">in</span> <span class="title">headers</span>
      <span class="title">nodes</span>.<span class="title">push</span>
        <span class="title">type</span>: '<span class="title">heading</span>'
        <span class="title">data</span>:  <span class="title">header</span>
        <span class="title">depth</span>: <span class="title">header</span>.<span class="title">level</span>

    @<span class="title">buildNodeTree</span> <span class="title">nodes</span>

  <span class="title">isIndexFile</span>: <span class="params">(filename)</span> -&gt;</span>
    !!(filename.match(<span class="regexp">/index\.[^\/]*$/i</span>) <span class="keyword">or</span> filename.match(<span class="regexp">/readme\.[^\/]*$/i</span>))</div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Generate a table of contents as a tree of {…, children: []} objects.</p>
<p>We take a list of file info objects, and a map of outlines to fileInfo.targetPath.</p>
<p>We want a pretty complex hierarchy in our table of contents:</p></div></div><div class="code"><div class="wrapper">  <span class="attribute">buildTableOfContents</span>: <span class="function"><span class="params">(files, outlines)</span> -&gt;</span>
    files = files.sort <span class="function"><span class="params">(a, b)</span> =&gt;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><ul>
<li>The index is always first in the table of contents.</li>
</ul></div></div><div class="code"><div class="wrapper">      <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> a.targetPath == <span class="string">'index'</span>
      <span class="keyword">return</span>  <span class="number">1</span> <span class="keyword">if</span> b.targetPath == <span class="string">'index'</span>

      <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> a.targetPath == b.targetPath</div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>index comes first</p></div></div><div class="code"><div class="wrapper">      <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> <span class="property">@isIndexFile</span>(a.projectPath) <span class="keyword">and</span>
        path.dirname(a.projectPath) == b.projectPath
      <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> <span class="property">@isIndexFile</span>(b.projectPath) <span class="keyword">and</span>
        path.dirname(b.projectPath) == a.projectPath</div></div></div><div class="segment"><div class="comments"><div class="wrapper"><ul>
<li>files matching a directory name come directly before it.  E.g. “foo” &lt; “foo/bar” &lt; “foz”</li>
</ul></div></div><div class="code"><div class="wrapper">      <span class="keyword">if</span> a.targetPath &lt; b.targetPath <span class="keyword">then</span> -<span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span>

    nodes    = []
    prevPath = []
    <span class="keyword">for</span> file <span class="keyword">in</span> files
      targetChunks = file.targetPath.split <span class="string">'/'</span>
      pathChunks   = targetChunks[<span class="number">0.</span>..-<span class="number">1</span>]</div></div></div><div class="segment"><div class="comments"><div class="wrapper"><ul>
<li>If a file has the same name as a directory or is index,
it takes ownership of that directory&#39;s folder.</li>
</ul></div></div><div class="code"><div class="wrapper">      <span class="keyword">if</span> !<span class="property">@isIndexFile</span>(file.projectPath)
        <span class="keyword">for</span> chunk, i <span class="keyword">in</span> pathChunks
          <span class="keyword">if</span> prevPath[i] != chunk</div></div></div><div class="segment"><div class="comments"><div class="wrapper"><ul>
<li>Otherwise we have a generic folder node that takes its place in
the table of contents.
TODO: We probably want some way to rename folders!</li>
</ul></div></div><div class="code"><div class="wrapper">            nodes.push
              <span class="attribute">type</span>:  <span class="string">'folder'</span>
              <span class="attribute">data</span>:
                <span class="attribute">path</span>:  targetChunks[<span class="number">0.</span>.i].join <span class="string">'/'</span>
                <span class="attribute">title</span>: targetChunks[i]
              <span class="attribute">depth</span>: i + <span class="number">1</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Make sure that we don&#39;t match directories several levels in,
after a fail.</p></div></div><div class="code"><div class="wrapper">            prevPath = []
      <span class="keyword">else</span>
        targetChunks = targetChunks.splice(<span class="number">0</span>, targetChunks.length - <span class="number">1</span>)

      prevPath = targetChunks

      fileData = _(file).clone()</div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Annotate the file data with a title to represent it.</p>
<p>If possible, we use the initial header in the file,</p></div></div><div class="code"><div class="wrapper">      <span class="keyword">if</span> outlines[file.targetPath]?[<span class="number">0</span>]?.data?.isFileHeader
        fileData.firstHeader = outlines[file.targetPath].shift()
        fileData.title       = fileData.firstHeader.data.title

        <span class="keyword">if</span> fileData.firstHeader.children?.length &gt; <span class="number">0</span>
          outlines[file.targetPath] = fileData.firstHeader.children.concat outlines[file.targetPath]</div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Otherwise we just fall back to the file&#39;s target path…</p></div></div><div class="code"><div class="wrapper">      <span class="keyword">else</span>
        fileData.title = path.basename file.targetPath

      depth = file.targetPath.split( <span class="string">'/'</span> ).length
      <span class="keyword">if</span> <span class="property">@isIndexFile</span>(file.projectPath) <span class="keyword">and</span> depth &gt; <span class="number">1</span>
        depth = depth - <span class="number">1</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>change previouse node style if it is file with same name with folder</p></div></div><div class="code"><div class="wrapper">      <span class="keyword">if</span> nodes.length
        prevNode = nodes[nodes.length - <span class="number">1</span>]
        <span class="keyword">if</span> prevNode.type == <span class="string">'file'</span> <span class="keyword">and</span> prevNode.depth &lt; depth
          prevNode.isFileFolder = <span class="literal">true</span>

      nodes.push
        <span class="attribute">type</span>:   <span class="string">'file'</span>
        <span class="attribute">data</span>:    fileData
        <span class="comment">#depth:   file.targetPath.split( path.join('/') ).length</span>
        <span class="attribute">depth</span>:   depth
        <span class="attribute">outline</span>: outlines[file.targetPath]

    <span class="property">@buildNodeTree</span> nodes</div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Take a flat, though ordered, list of nodes and convert them into a tree.</p>
<p>Nodes are expected to have a <code>depth</code> property.  Each node is annotated with an array of
<code>children</code> if it does not exist.  Children are appended, otherwise.</p></div></div><div class="code"><div class="wrapper">  <span class="attribute">buildNodeTree</span>: <span class="function"><span class="params">(nodes)</span> -&gt;</span>
    result = []
    stack  = []

    <span class="keyword">for</span> node <span class="keyword">in</span> nodes</div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Unwind the stack until we get to the first node that is at a lower depth than us.  We are
considered to be its child</p></div></div><div class="code"><div class="wrapper">      stack.pop() <span class="keyword">while</span> _(stack).last()?.depth &gt;= node.depth

      <span class="keyword">if</span> stack.length == <span class="number">0</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Top level nodes are directly returned in the result list.</p></div></div><div class="code"><div class="wrapper">        result.push node
      <span class="keyword">else</span>
        _(stack).last().children ||= []
        _(stack).last().children.push node

      stack.push node

    result</div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>It helps visually to separate headers that are not attached to other comments into their own
segment.</p></div></div><div class="code"><div class="wrapper">  <span class="attribute">segmentizeSoloHeaders</span>: <span class="function"><span class="params">(segments)</span> -&gt;</span>
    results = []
    <span class="keyword">for</span> segment <span class="keyword">in</span> segments
      headerOnly = segment.markdownedComments.match <span class="regexp">/^\s*&lt;h\d[^&gt;]*&gt;[^&lt;]*&lt;\/h\d&gt;\s*$/</span>
      <span class="keyword">if</span> headerOnly <span class="keyword">and</span> <span class="keyword">not</span> segment.highlightedCode.match <span class="regexp">/^\s*$/</span>
        results.push
          <span class="attribute">code</span>:               []
          <span class="attribute">comments</span>:           segment.comments
          <span class="attribute">highlightedCode</span>:    <span class="string">''</span>
          <span class="attribute">markdownedComments</span>: segment.markdownedComments

        results.push
          <span class="attribute">code</span>:               segment.code
          <span class="attribute">comments</span>:           []
          <span class="attribute">highlightedCode</span>:    segment.highlightedCode
          <span class="attribute">markdownedComments</span>: <span class="string">''</span>

      <span class="keyword">else</span>
        results.push segment

    results</div></div></div><div id="segment-footer"><div id="footer"><a href="https://github.com/druide/citare-scriptum" target="_blank">Generated by Citare scriptum</a></div></div></div></body></html>